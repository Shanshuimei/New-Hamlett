<div id="chat-history"></div>
<div style="margin-top: 10px; display: flex; align-items: center;">
    <button id="end-conversation-button">结束对话</button>
    <input type="text" id="user-input" placeholder="输入你的问题..." />
    <button id="send-button">发送</button>
</div>

<<script>>
setBackground("picture/reading room.jpeg");
<</script>>

<<script>>
    (function() {
        let conversationHistory = [];
        let socket;
        let isSocketConnected = false;
        let isEndingConversation = false;
        let hasNavigatedToPassage = false; // 标志位，防止多次跳转
        const prompt = "你是克劳狄斯，现任国王，刚刚继位。他人的眼中，你是一个聪明、圆滑、深谙权谋的政治家，但你的内心隐藏着对自己罪行的恐惧。你害怕真相被揭穿，却又极力保持镇定，展现出自信和威严。在与哈姆雷特（玩家）对话时：试探性对话时，对玩家表现出宽厚但隐约戒备的态度。留意玩家的言辞是否暗藏敌意，同时尝试控制对话方向，以显得自己毫无破绽。用以下方式回应：如果对话显得尖锐：转移话题，强调家族和国家的重要性。如果对话平和：展现表面的亲近，试图建立信任。关键词和风格言辞巧妙而隐晦，避免直接承认自己的罪行。适当使用权威性的语言来压制对方疑问。例如：“哈姆雷特，我的儿子，你最近似乎有些心事？或许是父亲的事让我疏忽了你。”“作为丹麦的王子，你的责任比个人情感更重要，不是吗？”表现情绪波动：如果被玩家直接质问，先保持冷静，随后逐渐流露出紧张或愤怒，但尽量不失控。强调自己对王位和王后的“正当拥有权”，试图混淆视听。例如：“这的确是个悲剧，但过去的事已无法改变，我们该向前看，而非追溯旧恨。”其他角色行为提示：在言辞中加入微妙的威胁，例如暗示如果哈姆雷特“越界”，可能会带来危险。试探玩家对王权的态度，比如是否对王位抱有野心。";

        function updateChatHistory() {
            const chatHistoryDiv = $("#chat-history");
            chatHistoryDiv.html(conversationHistory.map(msg => {
                return `<p><strong>${msg.role === "user" ? "你" : "克劳狄斯"}:</strong> ${msg.content}</p>`;
            }).join(""));
            chatHistoryDiv.scrollTop(chatHistoryDiv.prop("scrollHeight"));
        }

        function sendToWebSocket(message) {
            const payload = {
                "header": {
                    "app_id": '8b85b9c2',
                    "uid": '8b85b9c2',
                    "patch_id": ["1868135224229920768"]
                },
                "parameter": {
                    "chat": {
                        "domain": "xqwen257bchat",
                        "temperature": 0.5
                    }
                },
                "payload": {
                    "message": {
                        "text": [{"role": "user", "content": prompt + message}]
                    }
                }
            };
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify(payload));
            } else {
                console.error('WebSocket is not open.');
            }
        }

        async function callGPT(message) {
            const apiUrl = "wss://maas-api.cn-huabei-1.xf-yun.com/v1.1/chat";
            socket = new WebSocket(apiUrl);

            socket.onopen = () => {
                console.log('WebSocket connected');
                isSocketConnected = true;
                sendToWebSocket(message);
            };

            socket.onerror = (error) => {
                console.error('WebSocket Error', error);
            };

            socket.onclose = () => {
                console.log('WebSocket closed');
                isSocketConnected = false;
            };

            socket.onmessage = (event) => {
                try {
                    const response = JSON.parse(event.data);

                    if (response.payload && response.payload.choices && response.payload.choices.text) {
                        const textChunks = response.payload.choices.text;
                        let choice = "";

                        textChunks.forEach(chunk => {
                            const content = chunk.content || "";

                            if (isEndingConversation) {
                                if (conversationHistory.length > 0 && conversationHistory[conversationHistory.length - 1].role === "assistant") {
                                    conversationHistory[conversationHistory.length - 1].content += content;
                                } else {
                                    choice = content;
                                }
                                processEndConversationResponse(choice);
                            } else {
                                if (conversationHistory.length > 0 && conversationHistory[conversationHistory.length - 1].role === "assistant") {
                                    conversationHistory[conversationHistory.length - 1].content += content;
                                } else {
                                    conversationHistory.push({ "role": "assistant", "content": content });
                                }

                                updateChatHistory();
                            }
                        });
                    } else {
                        console.error('Unexpected WebSocket response structure:', response);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket data:', error);
                }
            };
        }

        function handleUserInput() {
            const userInput = $("#user-input").val().trim();
            if (!userInput) return;

            conversationHistory.push({"role": "user", "content": userInput});
            updateChatHistory();
            $("#user-input").val("");

            callGPT(userInput);
        }

        function endConversation() {
            const chatHistoryText = conversationHistory.map(msg => `${msg.role === "user" ? "你" : "克劳狄斯"}: ${msg.content}`).join("\n");
            const messageToSend = prompt + "以下是你们的历史对话：" + chatHistoryText + 
                                "请根据历史消息回答，你认为哈姆雷特发现你杀害他父亲的真相吗？只能回答是或者不是。";
            isEndingConversation = true;
            callGPT(messageToSend);
        }

        function processEndConversationResponse(response) {
            if (hasNavigatedToPassage) return; // 如果已经跳转过，则直接返回

            console.log('结束对话的AI回答：', response);
            const targetPassage = response.includes("不") ? "怀柔" : "先下手为强";
            State.variables.targetPassage = targetPassage; // 使用 SugarCube 的 State 变量
            console.log(`跳转到 passage: "${targetPassage}"`);

            hasNavigatedToPassage = true; // 标志位设置为 true
            SugarCube.Engine.play(targetPassage); // 跳转到目标 passage
        }

        $(document).ready(function() {
            $("#user-input").on("keydown", function(event) {
                if (event.key === "Enter") {
                    event.preventDefault();
                    handleUserInput();
                }
            });
            $("#send-button").on("click", handleUserInput);
            $("#end-conversation-button").on("click", endConversation);
        });
    })();
<</script>>

<<if $targetPassage>>
    <<goto $targetPassage>>
<</if>>